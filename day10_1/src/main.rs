use std::collections::HashSet;

fn get_data(v:&Vec<&str>)->HashSet<(usize,usize)> {
    let mut hash = HashSet::new();

    for y in 0..v.len() {
        for x in 0..v[y].len() {
            if v[y].chars().nth(x).unwrap()=='#' { hash.insert((x,y)); }
        }
    }
    hash
}

#[derive(Hash, Eq, PartialEq, Debug)]
struct Vec2{
    x: i64,
    y: i64,
}

impl Vec2 {
    fn new(fx:i64,fy:i64)->Vec2
    {
        Vec2{
            x:fx as i64,
            y:fy as i64,
        }
    }

    fn gdc(&self,a:u64,b:u64) -> u64
    {
        let mut aa = a;
        let mut bb = b;
        
        while bb!=0 {
            let t = bb;
            bb = aa%bb;
            aa = t;
        }
        aa
    }

    fn normal(&mut self)
    {
        let len = self.gdc(self.x.abs() as u64,self.y.abs() as u64);
        self.x/=len as i64;
        self.y/=len as i64;
    }
}

fn comp(v:&Vec<&str>) -> usize{

    let hash = get_data(v);
    let mut res = 0;

    for i in &hash {        
        let mut hash_dir : HashSet<Vec2> = HashSet::new();

        for j in &hash {
            if i!=j {
                   let mut dir = Vec2::new(j.0 as i64 - i.0 as i64 ,j.1 as i64 - i.1 as i64);
                   dir.normal();
                   hash_dir.insert(dir);
            }        
        }
        //println!("{:?}={}",i,hash_dir.len());
        res = std::cmp::max(res,hash_dir.len());        
    }
    res
}

fn main() {

let data = vec![
".#......##.#..#.......#####...#..",
"...#.....##......###....#.##.....",
"..#...#....#....#............###.",
".....#......#.##......#.#..###.#.",
"#.#..........##.#.#...#.##.#.#.#.",
"..#.##.#...#.......#..##.......##",
"..#....#.....#..##.#..####.#.....",
"#.............#..#.........#.#...",
"........#.##..#..#..#.#.....#.#..",
".........#...#..##......###.....#",
"##.#.###..#..#.#.....#.........#.",
".#.###.##..##......#####..#..##..",
".........#.......#.#......#......",
"..#...#...#...#.#....###.#.......",
"#..#.#....#...#.......#..#.#.##..",
"#.....##...#.###..#..#......#..##",
"...........#...#......#..#....#..",
"#.#.#......#....#..#.....##....##",
"..###...#.#.##..#...#.....#...#.#",
".......#..##.#..#.............##.",
"..###........##.#................",
"###.#..#...#......###.#........#.",
".......#....#.#.#..#..#....#..#..",
".#...#..#...#......#....#.#..#...",
"#.#.........#.....#....#.#.#.....",
".#....#......##.##....#........#.",
"....#..#..#...#..##.#.#......#.#.",
"..###.##.#.....#....#.#......#...",
"#.##...#............#..#.....#..#",
".#....##....##...#......#........",
"...#...##...#.......#....##.#....",
".#....#.#...#.#...##....#..##.#.#",
".#.#....##.......#.....##.##.#.##"];

    println!("res:{}",comp(&data));
}

#[test]
fn test0(){
    let data = vec![".#..#",
    ".....",
    "#####",
    "....#",
    "...##"];

    assert_eq!(comp(&data),8);
}

#[test]
fn test1(){

let data = vec![
".#..#..###",
"####.###.#",
"....###.#.",
"..###.##.#",
"##.##.#.#.",
"....###..#",
"..#.#..#.#",
"#..#.#.###",
".##...##.#",
".....#.#.."];

assert_eq!(comp(&data),41);
}

#[test]
fn test2(){

let data = vec![
".#..##.###...#######",
"##.############..##.",
".#.######.########.#",
".###.#######.####.#.",
"#####.##.#.##.###.##",
"..#####..#.#########",
"####################",
"#.####....###.#.#.##",
"##.#################",
"#####.##.###..####..",
"..######..##.#######",
"####.##.####...##..#",
".#####..#.######.###",
"##...#.##########...",
"#.##########.#######",
".####.#.###.###.#.##",
"....##.##.###..#####",
".#.#.###########.###",
"#.#.#.#####.####.###",
"###.##.####.##.#..##"];

assert_eq!(comp(&data),210);
}
